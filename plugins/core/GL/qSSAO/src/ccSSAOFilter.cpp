// ##########################################################################
// #                                                                        #
// #                       CLOUDCOMPARE PLUGIN: qSSAO                       #
// #                                                                        #
// #  This program is free software; you can redistribute it and/or modify  #
// #  it under the terms of the GNU General Public License as published by  #
// #  the Free Software Foundation; version 2 or later of the License.      #
// #                                                                        #
// #  This program is distributed in the hope that it will be useful,       #
// #  but WITHOUT ANY WARRANTY; without even the implied warranty of        #
// #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the          #
// #  GNU General Public License for more details.                          #
// #                                                                        #
// #          COPYRIGHT: EDF R&D / TELECOM ParisTech (ENST-TSI)             #
// #                                                                        #
// ##########################################################################

#include "ccSSAOFilter.h"

// CC_FBO
#include <ccBilateralFilter.h>
#include <ccFrameBufferObject.h>
#include <ccShader.h>
// qCC_gl
#include <ccGLUtils.h>

// GUIs generated by Qt Designer
#include <ui_ssaoDialog.h>

// Qt
#include <QDialog>
#include <QSettings>

// system
#include <math.h>
#include <random>
#include <stdlib.h>
#include <vector>

#ifndef GL_RGBA32F
#define GL_RGBA32F 0x8814
#endif

#ifndef GL_RGB16F
#define GL_RGB16F 0x881B
#endif

//! Maximum number of sampling directions
static const int MAX_N = 32; // see shader code

//! SSAO filter dialog
class SSAODialog : public QDialog
    , public Ui::SSAODialog
{
  public:
	//! Constructor
	SSAODialog(QWidget* parent = nullptr)
	    : QDialog(parent)
	{
		setupUi(this);
	}

	//! Inits the dialog from persistent settings
	void initFromPersistentSettings()
	{
		QSettings settings;
		settings.beginGroup("SSAO");
		{
			radiusDoubleSpinBox->setValue(settings.value("Radius", radiusDoubleSpinBox->value()).toDouble());
			amplificationDoubleSpinBox->setValue(settings.value("Amplification", amplificationDoubleSpinBox->value()).toDouble());
			attenuationDoubleSpinBox->setValue(settings.value("Attenuation", attenuationDoubleSpinBox->value()).toDouble());
			reflectCheckBox->setChecked(settings.value("UseReflectTexture", reflectCheckBox->isChecked()).toBool());
			seedSpinBox->setValue(settings.value("RandomSeed", seedSpinBox->value()).toInt());
			settings.beginGroup("BilateralFilter");
			{
				bfGroupBox->setChecked(settings.value("Enabled", bfGroupBox->isChecked()).toBool());
				bfRadiusSpinBox->setValue(settings.value("Radius", bfRadiusSpinBox->value()).toDouble());
				bfSigmaXYDoubleSpinBox->setValue(settings.value("SigmaXY", bfSigmaXYDoubleSpinBox->value()).toDouble());
				bfSigmaZDoubleSpinBox->setValue(settings.value("SigmaZ", bfSigmaZDoubleSpinBox->value()).toDouble());
			}
			settings.endGroup();
		}
		settings.endGroup();
	}

	void toPersistentSettings()
	{
		QSettings settings;
		settings.beginGroup("SSAO");
		{
			settings.setValue("Radius", radiusDoubleSpinBox->value());
			settings.setValue("Amplification", amplificationDoubleSpinBox->value());
			settings.setValue("Attenuation", attenuationDoubleSpinBox->value());
			settings.setValue("UseReflectTexture", reflectCheckBox->isChecked());
			settings.setValue("RandomSeed", seedSpinBox->value());
			settings.beginGroup("BilateralFilter");
			{
				settings.setValue("Enabled", bfGroupBox->isChecked());
				settings.setValue("Radius", bfRadiusSpinBox->value());
				settings.setValue("SigmaXY", bfSigmaXYDoubleSpinBox->value());
				settings.setValue("SigmaZ", bfSigmaZDoubleSpinBox->value());
			}
			settings.endGroup();
		}
	}
};

ccSSAOFilter::ccSSAOFilter()
    : ccGlFilter("Screen Space Ambient Occlusion")
    , m_w(0)
    , m_h(0)
    , m_fbo(nullptr)
    , m_shader(nullptr)
    , m_texReflect(0)
    , m_Kz(500.0f) // attenuation with distance
    , m_R(0.05f)   // radius in image of neighbour sphere
    , m_F(50.0f)   // amplification
    , m_randSeed(0)
    , m_bilateralFilter(nullptr)
    , m_bilateralFilterEnabled(false)
    , m_bilateralGHalfSize(2)
    , m_bilateralGSigma(0.5f)
    , m_bilateralGSigmaZ(0.4f)
    , m_glFuncIsValid(0)
{
}

ccSSAOFilter::~ccSSAOFilter()
{
	reset();
}

ccGlFilter* ccSSAOFilter::clone() const
{
	ccSSAOFilter* filter = new ccSSAOFilter();

	// copy parameters
	filter->setParameters(m_Kz, m_R, m_F);

	return filter;
}

void ccSSAOFilter::reset()
{
	if (m_glFuncIsValid && m_glFunc.glIsTexture(m_texReflect))
	{
		m_glFunc.glDeleteTextures(1, &m_texReflect);
	}
	m_texReflect = 0;

	if (m_fbo)
	{
		delete m_fbo;
		m_fbo = nullptr;
	}

	if (m_shader)
	{
		delete m_shader;
		m_shader = nullptr;
	}

	if (m_bilateralFilter)
	{
		delete m_bilateralFilter;
		m_bilateralFilter = nullptr;
	}
}

bool ccSSAOFilter::init(unsigned width, unsigned height, const QString& shadersPath, QString& error, bool silent)
{
	if (width == 0 || height == 0)
	{
		error = "Invalid texture size";
		return false;
	}

	// init parameters
	bool enableBilateralFilter = false;
	bool useReflectTexture     = false;

	if (!silent)
	{
		// init UI from persistent settings
		SSAODialog ssaoDlg;
		ssaoDlg.initFromPersistentSettings();
		if (0 == ssaoDlg.exec())
		{
			// cancelled by user
			return false;
		}
		ssaoDlg.toPersistentSettings();
		{
			m_R               = ssaoDlg.radiusDoubleSpinBox->value() / 100;
			m_F               = ssaoDlg.amplificationDoubleSpinBox->value();
			m_Kz              = ssaoDlg.attenuationDoubleSpinBox->value();
			useReflectTexture = ssaoDlg.reflectCheckBox->isChecked();
			{
				enableBilateralFilter = ssaoDlg.bfGroupBox->isChecked();
				m_bilateralGHalfSize  = ssaoDlg.bfRadiusSpinBox->value();
				m_bilateralGSigma     = ssaoDlg.bfSigmaXYDoubleSpinBox->value();
				m_bilateralGSigmaZ    = ssaoDlg.bfSigmaZDoubleSpinBox->value();
			}
			m_randSeed = static_cast<unsigned>(std::max(0, ssaoDlg.seedSpinBox->value()));
		}
	}
	else
	{
		enableBilateralFilter = m_bilateralFilterEnabled;
		useReflectTexture     = (m_glFuncIsValid && m_glFunc.glIsTexture(m_texReflect));
	}

	sampleSphere();

	if (!m_glFuncIsValid)
	{
		if (!m_glFunc.initializeOpenGLFunctions())
		{
			return false;
		}
		m_glFuncIsValid = true;
	}

	setValid(false);

	// in case of reinit
	if (!m_fbo)
	{
		m_fbo = new ccFrameBufferObject();
	}

	if (!m_fbo->init(width, height)
	    || !m_fbo->initColor(GL_RGBA32F, GL_RGBA, GL_FLOAT, GL_LINEAR))
	{
		error = "[SSAO] FrameBufferObject initialization failed!";
		reset();
		return false;
	}

	if (!m_shader)
	{
		m_shader = new ccShader();
		if (!m_shader->fromFile(shadersPath, "SSAO/ssao", error))
		{
			error = "[SSAO] Can't load SSAO shaders";
			reset();
			return false;
		}
	}

	m_bilateralFilterEnabled = enableBilateralFilter;
	if (m_bilateralFilterEnabled)
	{
		if (!m_bilateralFilter)
		{
			m_bilateralFilter = new ccBilateralFilter();
		}
		if (!m_bilateralFilter->init(width, height, shadersPath, error, silent))
		{
			delete m_bilateralFilter;
			m_bilateralFilter        = nullptr;
			m_bilateralFilterEnabled = false;
		}
		else
		{
			m_bilateralFilter->useExistingViewport(true);
		}
	}
	else if (m_bilateralFilter)
	{
		delete m_bilateralFilter;
		m_bilateralFilter = nullptr;
	}

	m_w = width;
	m_h = height;

	// remove the existing texture
	if (m_glFunc.glIsTexture(m_texReflect))
	{
		m_glFunc.glDeleteTextures(1, &m_texReflect);
	}
	m_texReflect = 0;

	if (useReflectTexture)
	{
		initReflectTexture();
	}

	setValid(true);

	return true;
}

void ccSSAOFilter::sampleSphere()
{
	m_ssaoNeighbours.resize(3 * MAX_N);

	// Initialize the random number generator
	std::mt19937                          mt(m_randSeed);
	std::uniform_real_distribution<float> dist(-1.0, 1.0);

	// Draw in sphere
	for (unsigned nInsideSphere = 0; nInsideSphere < MAX_N;)
	{
		float px = dist(mt);
		float py = dist(mt);
		float pz = dist(mt);

		if (px * px + py * py + pz * pz <= 1.0f)
		{
			m_ssaoNeighbours[3 * nInsideSphere]     = px;
			m_ssaoNeighbours[3 * nInsideSphere + 1] = py;
			m_ssaoNeighbours[3 * nInsideSphere + 2] = pz;

			++nInsideSphere;
		}
	}
}

void ccSSAOFilter::shade(GLuint texDepth, GLuint texColor, ViewportParameters& parameters)
{
	if (!isValid())
	{
		return;
	}
	assert(m_fbo);

	// we must use corner-based screen coordinates
	m_glFunc.glMatrixMode(GL_PROJECTION);
	m_glFunc.glPushMatrix();
	m_glFunc.glLoadIdentity();
	m_glFunc.glOrtho(0.0, static_cast<GLdouble>(m_w), 0.0, static_cast<GLdouble>(m_h), 0.0, 1.0);
	m_glFunc.glMatrixMode(GL_MODELVIEW);
	m_glFunc.glPushMatrix();
	m_glFunc.glLoadIdentity();
	assert(m_glFunc.glGetError() == GL_NO_ERROR);

	bool hasReflectTexture = m_glFunc.glIsTexture(m_texReflect);

	m_fbo->start();

	m_shader->bind();
	m_shader->setUniformValue("s_Depth", 0);
	m_shader->setUniformValue("s_Reflect", 1);
	m_shader->setUniformValue("s2_Colors", 2);
	m_shader->setUniformValue("R", m_R);
	m_shader->setUniformValue("F", m_F);
	m_shader->setUniformValue("Kz", m_Kz);
	m_shader->setUniformValue("UseReflect", hasReflectTexture ? 1 : 0);
	m_shader->setUniformValueArray("P", m_ssaoNeighbours.data(), MAX_N, 3);

	m_glFunc.glActiveTexture(GL_TEXTURE2);
	m_glFunc.glBindTexture(GL_TEXTURE_2D, texColor);

	GLuint texReflect = 0;
	if (hasReflectTexture)
	{
		m_glFunc.glActiveTexture(GL_TEXTURE1);
		m_glFunc.glBindTexture(GL_TEXTURE_2D, m_texReflect);
	}

	m_glFunc.glActiveTexture(GL_TEXTURE0);
	ccGLUtils::DisplayTexture2DPosition(texDepth, 0, 0, m_w, m_h);

	if (hasReflectTexture)
	{
		m_glFunc.glActiveTexture(GL_TEXTURE1);
		m_glFunc.glBindTexture(GL_TEXTURE_2D, 0);
	}

	m_glFunc.glActiveTexture(GL_TEXTURE2);
	m_glFunc.glBindTexture(GL_TEXTURE_2D, 0);

	m_shader->release();
	m_fbo->stop();

	if (m_bilateralFilter)
	{
		m_bilateralFilter->setParams(m_bilateralGHalfSize, m_bilateralGSigma, m_bilateralGSigmaZ);
		m_bilateralFilter->shade(texDepth, m_fbo->getColorTexture(), parameters);
		assert(m_glFunc.glGetError() == GL_NO_ERROR);
	}

	// restore GL_TEXTURE_0 by default
	m_glFunc.glActiveTexture(GL_TEXTURE0);

	m_glFunc.glMatrixMode(GL_PROJECTION);
	m_glFunc.glPopMatrix();
	m_glFunc.glMatrixMode(GL_MODELVIEW);
	m_glFunc.glPopMatrix();

	auto lastGLError = m_glFunc.glGetError();
	if (GL_NO_ERROR != lastGLError)
	{
		ccLog::Warning(QString("[SSAO] GL error detected: %1").arg(lastGLError));
	}
}

GLuint ccSSAOFilter::getTexture()
{
	if (m_bilateralFilter)
	{
		return m_bilateralFilter->getTexture();
	}

	return (m_fbo ? m_fbo->getColorTexture() : 0);
}

void ccSSAOFilter::setParameters(float Kz, float R, float F)
{
	m_Kz = Kz;
	m_R  = R;
	m_F  = F;
}

void ccSSAOFilter::initReflectTexture()
{
	/*** INIT TEXTURE OF RELFECT VECTORS ***/
	/***       Fully random texture      ***/
	unsigned           texSize = m_w * m_h;
	std::vector<float> reflectTexture;
	try
	{
		reflectTexture.resize(3 * texSize, 0);
	}
	catch (const std::bad_alloc&)
	{
		// not enough memory
		return;
	}

	std::mt19937                          mt(m_randSeed);
	std::uniform_real_distribution<float> dist(-1.0, 1.0);

	for (unsigned i = 0; i < texSize; i++)
	{
		CCVector3d P;
		while (true)
		{
			P.x = dist(mt);
			P.y = dist(mt);
			P.z = dist(mt);

			double norm2 = P.norm2d();
			if (norm2 > 0.001 && norm2 <= 1.0)
			{
				P /= sqrt(norm2);
				break;
			}
		}

		// map the point coordinates in [0;1]
		reflectTexture[i * 3]     = static_cast<float>((1.0 + P.x) / 2);
		reflectTexture[i * 3 + 1] = static_cast<float>((1.0 + P.y) / 2);
		reflectTexture[i * 3 + 2] = static_cast<float>((1.0 + P.z) / 2);
	}

	assert(m_glFuncIsValid);

	m_glFunc.glPushAttrib(GL_ENABLE_BIT);
	m_glFunc.glEnable(GL_TEXTURE_2D);

	m_glFunc.glGenTextures(1, &m_texReflect);
	m_glFunc.glBindTexture(GL_TEXTURE_2D, m_texReflect);
	m_glFunc.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	m_glFunc.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	m_glFunc.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	m_glFunc.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	m_glFunc.glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, m_w, m_h, 0, GL_RGB, GL_FLOAT, &reflectTexture[0]);
	m_glFunc.glBindTexture(GL_TEXTURE_2D, 0);

	m_glFunc.glPopAttrib();
	assert(m_glFunc.glGetError() == GL_NO_ERROR);

	// According to Wikipedia, noise is made of 4*4 repeated tiles to have only high frequency
}
